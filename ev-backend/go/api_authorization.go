/*
 * EV Backend
 *
 * API version: 0.0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package ev_backend

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"errors"
	"io"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"strings"
	"time"
	// "github.com/authlete/authlete-go/api"
	// "github.com/authlete/authlete-go/conf"
	// "github.com/authlete/authlete-go/dto"
)

type Session struct {
	PkceVerifier string
	EmspId       string
}

var sessions = make(map[string]Session)

var randomCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

var pkceChallengeCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"

func GenerateRandomString(length int, charset string) string {
	random := rand.New(rand.NewSource(time.Now().UnixNano()))
	charsetLength := len(charset)
	result := make([]byte, length)
	for i := range result {
		result[i] = charset[random.Intn(charsetLength)]
	}
	return string(result)
}

func GetEmsp(id string) *Emsp {
	for _, emsp := range Emsps {
		if emsp.Id == id {
			return &emsp
		}
	}
	return nil
}

func GetDiscoveryDocument(baseUrl string) (map[string]interface{}, error) {
	// Build Discovery URL
	discoveryUrl := baseUrl + "/.well-known/openid-configuration"

	// Request discovery document
	resp, err := http.Get(discoveryUrl)
	if err != nil {
		return nil, err
	}

	// Read HTTP body
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse HTTP body
	var discoveryDocument map[string]interface{}
	err = json.Unmarshal(body, &discoveryDocument)
	if err != nil {
		return nil, err
	}

	return discoveryDocument, nil
}

func GetPkce() (string, string, error) {
	// Generate random PKCE Verifier
	pkceVerifier := GenerateRandomString(128, randomCharSet)

	// Encode Verifier to ASCII
	asciiEncodedVerifier := []byte(pkceVerifier)
	//  make([]byte, 128)
	// sEnc := b64. b64.StdEncoding.EncodeToString([]byte(pkceVerifier))
	// ascii85.Encode(asciiEncodedVerifier, []byte(pkceVerifier))

	// Generate SHA-256 hash from ASCII-encoded verifier
	hash := sha256.New()
	_, err := hash.Write(asciiEncodedVerifier)
	if err != nil {
		return "", "", err
	}
	sha256Verifier := hash.Sum(nil)

	// Encode the SHA-256 hash to base64url
	pkceChallenge := base64.URLEncoding.EncodeToString(sha256Verifier)

	return pkceVerifier, pkceChallenge, nil
}

// func CreateAuthleteConfiguration() conf.AuthleteConfiguration {
// 	apiKey := os.Getenv("API_KEY")
// 	apiSecret := os.Getenv("API_SECRET")
// 	cnf := conf.AuthleteSimpleConfiguration{}
// 	cnf.SetBaseUrl("https://api.authlete.com/")
// 	cnf.SetServiceApiKey(apiKey)
// 	cnf.SetServiceApiSecret(apiSecret)

// 	return &cnf
// }

func InitializeAuthorizationFlow(w http.ResponseWriter, r *http.Request) {
	// Parse Authorization Request body
	var authorizationRequest AuthorizationRequest
	err := json.NewDecoder(r.Body).Decode(&authorizationRequest)
	if err != nil {
		log.Printf("Failed to parse AuthorizationRequest")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Search for eMSP with requested ID
	emsp := GetEmsp(authorizationRequest.EmspId)
	if emsp == nil {
		log.Printf("Unknown eMSP with ID \"" + authorizationRequest.EmspId + "\"")
		w.WriteHeader(http.StatusNotFound)
		return
	}

	// Get discovery document
	discoveryDocument, err := GetDiscoveryDocument(emsp.BaseUrl)
	if err != nil {
		log.Printf("Failed to load discovery document for eMSP with Base URL \"" + emsp.BaseUrl + "\"")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get PAR endpoint from discovery document
	parEndpoint, found := discoveryDocument["pushed_authorization_request_endpoint"].(string)
	if !found {
		log.Printf("eMSP \"" + emsp.BaseUrl + "\" does not support Pushed Authorization Requests")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// parEndpoint := "https://api.authlete.com/api/pushed_auth_req"

	// cnf := CreateAuthleteConfiguration()
	// api := api.New(cnf)

	// Prepare PKCE
	pkceVerifier, pkceChallenge, err := GetPkce()
	if err != nil {
		log.Printf("Failed to generate PKCE challenge")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create new session
	sessionId := GenerateRandomString(20, randomCharSet)
	sessions[sessionId] = Session{
		PkceVerifier: pkceVerifier,
		EmspId:       emsp.Id,
	}

	// Encode authorization details:
	authorizationDetails, err := json.Marshal(
		[1]AuthorizationDetail{
			*authorizationRequest.Detail,
		},
	)
	if err != nil {
		log.Printf("Failed to serialize authorization details")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Get Client Secret
	clientSecret, found := ClientSecrets[emsp.Id]
	if !found {
		log.Printf("Client Secret for Client ID \"" + emsp.ClientId + "\" not found")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Prepare body parameters
	bodyParameters := url.Values{}
	// OAuth Authorization parameters according to RFC 6749:
	bodyParameters.Set("response_type", "code")
	bodyParameters.Set("client_id", emsp.ClientId)
	bodyParameters.Set("redirect_uri", clientSecret.RedirectUri)
	bodyParameters.Set("scope", "pnc")
	bodyParameters.Set("state", sessionId)
	// PKCE parameters according to RFC 7636:
	bodyParameters.Set("code_challenge", pkceChallenge)
	bodyParameters.Set("code_challenge_method", "S256")
	// RAR parameters according to RFC 9396:
	bodyParameters.Set("authorization_details", string(authorizationDetails))

	// Encode body parameters to string
	bodyString := bodyParameters.Encode()

	log.Printf("%q", bodyString)

	// parBody := dto.PushedAuthReqRequest{
	// 	ClientId:     emsp.ClientId,
	// 	ClientSecret: ClientSecrets[emsp.ClientId].Secret,
	// 	Parameters:   bodyString,
	// }
	// parResponse, err := api.PushAuthorizationRequest(&parBody)
	// // Send Pushed Authorization Request to Authorization Endpoint.
	parResponse, err := http.Post(parEndpoint, "application/x-www-form-urlencoded", strings.NewReader(bodyString))
	// request, err := http.NewRequest("POST", parEndpoint, strings.NewReader(bodyString))
	if err != nil {
		log.Printf("Failed to send Pushed Authorization Request: " + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Read PAR response body
	defer parResponse.Body.Close()
	body, err := io.ReadAll(parResponse.Body)
	if err != nil {
		log.Printf("Failed to read PAR response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Parse PAR response body
	var responseBody ParResponseBody
	err = json.Unmarshal(body, &responseBody)
	if err != nil {
		log.Printf("Failed to parse PAR response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create and serialize response
	result := AuthorizationResponse{
		State:      sessionId,
		RequestUri: responseBody.RequestUri, //parResponse.RequestUri,
	}
	resultData, err := json.Marshal(result)
	if err != nil {
		log.Printf("Failed to serialize response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write serialized result
	_, err = w.Write(resultData)
	if err != nil {
		log.Printf("Failed to write response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write header and status code
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
}

type ClientSecret struct {
	Secret      string `json:"secret"`
	RedirectUri string `json:"redirect_uri"`
}

func ReadClientSecrets(file string) (map[string]ClientSecret, error) {
	// Read emsp file and return 500 response if failed
	data, err := os.ReadFile(file)
	if err != nil {
		return nil, err
	}

	// JSON serialize emsps array
	var clientSecrets map[string]ClientSecret
	err = json.Unmarshal(data, &clientSecrets)
	if err != nil {
		return nil, err
	}

	return clientSecrets, nil
}

var ClientSecrets map[string]ClientSecret

func FinishAuthorizationFlow(w http.ResponseWriter, r *http.Request) {
	// Parse Finish Authorization Request body
	var authorizationRequest FinishAuthorizationRequest
	err := json.NewDecoder(r.Body).Decode(&authorizationRequest)
	if err != nil {
		log.Printf("Failed to parse FinishAuthorizationRequest")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	session, found := sessions[authorizationRequest.State]
	if !found {
		log.Printf("Session not found")
		w.WriteHeader(http.StatusNotFound)
		return
	}

	emsp := GetEmsp(session.EmspId)
	if emsp == nil {
		log.Printf("eMSP not found")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	discoveryDocument, err := GetDiscoveryDocument(emsp.BaseUrl)
	if err != nil {
		log.Printf("Failed to discovery document")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get PAR endpoint from discovery document
	tokenEndpoint, found := discoveryDocument["token_endpoint"].(string)
	if !found {
		log.Printf("eMSP \"" + emsp.BaseUrl + "\" does not support Pushed Authorization Requests")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get Client Secret
	clientSecret, found := ClientSecrets[emsp.ClientId]
	if !found {
		log.Printf("Client Secret for Client ID \"" + emsp.ClientId + "\" not found")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Prepare body parameters
	tokenRequestBodyParameters := url.Values{}
	// OAuth Authorization parameters according to RFC 6749:
	tokenRequestBodyParameters.Set("grant_type", "authorization_code")
	tokenRequestBodyParameters.Set("client_id", emsp.ClientId)
	tokenRequestBodyParameters.Set("client_secret", clientSecret.Secret)
	tokenRequestBodyParameters.Set("code", authorizationRequest.AuthCode)
	tokenRequestBodyParameters.Set("redirect_uri", clientSecret.RedirectUri)
	tokenRequestBodyParameters.Set("scope", "pnc")
	tokenRequestBodyParameters.Set("state", authorizationRequest.State)
	// PKCE parameters according to RFC 7636:
	tokenRequestBodyParameters.Set("code_verifier", session.PkceVerifier)

	// Encode body parameters to string
	tokenRequestBodyString := tokenRequestBodyParameters.Encode()

	// Send Token Request to Token Endpoint.
	tokenRequest, err := http.NewRequest("POST", tokenEndpoint, strings.NewReader(tokenRequestBodyString))
	if err != nil {
		log.Printf("Failed to send Token Request")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer tokenRequest.Body.Close()

	// Read Token response body
	defer tokenRequest.Response.Body.Close()
	tokenResponseBodyString, err := io.ReadAll(tokenRequest.Response.Body)
	if err != nil {
		log.Printf("Failed to read Token response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Parse Token response body
	var tokenResponseBody map[string]interface{}
	err = json.Unmarshal(tokenResponseBodyString, &tokenResponseBody)
	if err != nil {
		log.Printf("Failed to parse Token response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get access token from token response body
	accessToken, found := tokenResponseBody["access_token"].(string)
	if !found {
		log.Printf("Access Token not found in token response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create certificate signing request
	csr, err := CreateCsr()
	if err != nil {
		log.Printf("Failed to create CSR")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	csrEndpoint := os.Getenv("CSR_ENDPOINT")
	if csrEndpoint != "" {
		log.Printf("CSR_ENDPOINT not defined")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Send CSR to CSR Endpoint.
	csrRequest, err := http.NewRequest("POST", csrEndpoint, strings.NewReader(csr))
	if err != nil {
		log.Printf("Failed to send Token Request")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer csrRequest.Body.Close()

	// Add request headers
	csrRequest.Header.Add("content-type", "application/pkcs10")
	csrRequest.Header.Add("authorization", "bearer "+accessToken)

	// Read Token response body
	defer csrRequest.Response.Body.Close()
	csrResponseBodyString, err := io.ReadAll(csrRequest.Response.Body)
	if err != nil {
		log.Printf("Failed to read CSR response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	certificateFile := os.Getenv("OUTPUT_FILE")
	if certificateFile == "" {
		log.Printf("OUTPUT_FILE not defined")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	err = WriteCertificate(csrResponseBodyString, certificateFile)
	if err != nil {
		log.Printf("Failed to write certificate")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func CreateCsr() (string, error) {
	// Execute OpenSSL Command to generate CSR
	cmd := exec.Command("./csr.sh")
	if cmd == nil {
		return "", errors.New("Failed to execute CSR")
	}

	// Read CSR file
	data, err := os.ReadFile("./request.csr")
	if err != nil {
		return "", err
	}

	// Return CSR file as string
	return string(data), nil
}

func WriteCertificate(csrResponse []byte, file string) error {
	err := os.WriteFile(file, csrResponse, 0400)
	return err
}
