theory oidc_pnc

/*
Tamarin model for oidc_pnc

Run with: 
time tamarin-prover --prove --quit-on-warning --auto-sources --stop-on-trace=SEQDFS --heuristic=O --oraclename=oracle  oidc_pnc.spthy +RTS -N6 -RTS

==============================================================================
summary of summaries:

analyzed: oidc_pnc.spthy

  reuse_User_LTK (all-traces): verified (50 steps)
  reuse_User_SK (all-traces): verified (14 steps)
  reuse_EV_LTK (all-traces): verified (8 steps)
  correctness_simple6 (exists-trace): verified (16 steps)
  correctness_simple7 (exists-trace): verified (24 steps)
  correctness_simple81 (exists-trace): verified (28 steps)
  correctness_simple82 (exists-trace): verified (33 steps)
  correctness_simple83 (exists-trace): verified (30 steps)
  correctness_simple8 (exists-trace): verified (30 steps)
  correctness_simple9 (exists-trace): verified (40 steps)
  auth2_weak_EV_UA0 (all-traces): verified (1656 steps)
  auth2_weak_EV_UA (all-traces): verified (1656 steps)
  auth2_non_inj_EV_UA (all-traces): verified (1656 steps)
  auth2_inj_EV_UA (all-traces): verified (1657 steps)
  auth3_non_inj_User_EMSP (all-traces): verified (5030 steps)
  auth3_inj_User_EMSP (all-traces): verified (5050 steps)
  auth5_non_inj_EV_EMSP (all-traces): verified (8661 steps)
  auth5_inj_EV_EMSP (all-traces): verified (43557 steps)
  auth6_non_inj_EMSP_EV_CC (all-traces): verified (8560 steps)
  auth6_inj_EMSP_EV_CC (all-traces): verified (8596 steps)
  AUTO_typing (all-traces): verified (4941 steps)

==============================================================================

real	325m16,285s
user	1170m52,795s
sys	699m45,870s



tested with Tamarin 1.6.1


interactive with:
tamarin-prover interactive --quit-on-warning --auto-sources oidc_pnc.spthy --stop-on-trace=SEQDFS --heuristic=O --oraclename=oracle +RTS -N6 -RTS


*/
begin

//multiset, asymmetric-encryption, signing, 
builtins:   symmetric-encryption, diffie-hellman, hashing, signing, asymmetric-encryption
functions: 	f3/4, f4/4, f5/9, f6/7, g2/4, mac/2 

// **** Protocol ****
equations:
	fst(<x.1, x.2>) = x.1,
	snd(<x.1, x.2>) = x.2,
    f4(U, V, X, Z) = mac(<U, V, Z>, X), //LE Secure Connections confirm value generation function f4
	//	f5(W, N1, N2, A1, A2) = <mac(<'0', 'btle', N1, N2, A1, A2, '256'>, mac(W, '6C888391_AAF5A538_60370BDB_5A6083BE')),
	//							 mac(<'1', 'btle', N1, N2, A1, A2, '256'>, mac(W, '6C888391_AAF5A538_60370BDB_5A6083BE'))>, //LE Secure Connections key generation function f5
	f5(W, N1, N2, A1, A2, c1, c2, btle, Tkey) = <mac(<c1, btle, N1, N2, A1, A2>, mac(W, Tkey)),
							 			   		 mac(<c2, btle, N1, N2, A1, A2>, mac(W, Tkey))>, //LE Secure Connections key generation function f5
	f6(W, N1, N2, R, IOcap, A1, A2) = mac(<N1, N2, R, IOcap, A1, A2>, W), //LE Secure Connections check value generation function f6
	g2(U, V, X, Y) = mac(<U, V, Y>, X) //LE Secure Connections numeric comparison value generation function g2
	



// *** Secure Channel rules (visual) ***
rule ChanOut_V [colour=ffffff]:
    [ Out_S_V( V ) ]
  --[ ChanOut_V( V ) ]->
    [ Sec_V( V ) ] //TODO: , Out( V ) 

rule ChanIn_V [colour=ffffff]:
    [ Sec_V( V ) ] //TODO: !Sec_V
  --[ ChanIn_V( V ) ]->
    [ In_S_V( V ) ]






// *** Standard Restrictions ***
restriction Equality: "All x y #i. Eq(x,y) @i ==> x = y"
restriction NotEquality: "All x y #i. NEq(x,y) @i ==> not(x = y)"
restriction OnlyOnce: "All #i #j x. OnlyOnce(x) @i & OnlyOnce(x)@j ==> #i = #j"
//restriction UniqueID: "All #i #j a b x. UniqueID(a, x) @i & UniqueID(b, x)@j ==> a = b"
 

/******************************************/
// init
/******************************************/

rule EMSP_Setup:
let
	EMSP_PK = pk(~EMSP_SK)
in
[ Fr(~EMSP_SK) ]
--[ //Restrictions
	OnlyOnce(<'EMSP_Setup', $EMSP_Name>), 
	
	// Correctness events
	EMSP_Setup(),
	OnlyOnce_Correctness(<'EMSP_Setup', $EMSP_Name>)
]->
[	
	Out( <$EMSP_Name, EMSP_PK> ),
	!EMSP_Pk( $EMSP_Name, EMSP_PK ),
	!EMSP_Sk( $EMSP_Name, ~EMSP_SK )
]

rule LongTermKey_KeyReveal_EMSP:
[	!EMSP_Sk( entity, key ) ] 
--[ KeyReveal('LongTermKey_KeyReveal_EMSP', entity) ]->
[	Out(key) ]


rule OEM_OAuth_Setup:
let
	OAuth_PK = pk(~OAuth_SK)
in
[ Fr(~OAuth_SK) ]
--[ //Restrictions
	OnlyOnce(<'OEM_OAuth_Setup', $OEM_Name, $EV_Client_ID>), 
	
	// Correctness events
	OEM_OAuth_Setup(),
	OnlyOnce_Correctness(<'OEM_OAuth_Setup', $OEM_Name>)
]->
[	
	Out( <$OEM_Name, $EV_Client_ID, OAuth_PK> ),
	!OEM_OAuth_Pk( $OEM_Name, $EV_Client_ID, OAuth_PK ),
	!OEM_OAuth_Sk( $OEM_Name, $EV_Client_ID, ~OAuth_SK )
]

rule LongTermKey_KeyReveal_OAuth:
[	!OEM_OAuth_Sk( entity, client, key ) ] 
--[ KeyReveal('LongTermKey_KeyReveal_OAuth', entity), KeyReveal('LongTermKey_KeyReveal_OAuth', client) ]->
[	Out(key) ]


rule EV_starts_Setup:
let
	PKb = 'g'^~SKb
in
[
	Fr(~SKb)
]
--[ //Restrictions
	//OnlyOnce(<'EV_starts_Setup', $device_name>), 
	//OnlyOnce(<'EV_starts_Setup', $reg_endpoint>), 
	
	// Correctness events
	EV_starts_Setup(),
	OnlyOnce_Correctness('EV_starts_Setup')
]->
[	
	EV_State0($device_name, $reg_endpoint, ~SKb)
]


rule User_Password_Setup:
[ 
	Fr(~pw),
	!EMSP_Pk( $EMSP_Name, EMSP_PK )
]
--[ //Restrictions
	OnlyOnce(<'User_Password', $account_name>), 
	
	// Correctness events
	User_Password_Setup(),
	OnlyOnce_Correctness('User_Password_Setup')
]->
[	
	!User_Password($user_name, $account_name, ~pw, $EMSP_Name)
]

rule LongTermKey_KeyReveal_Password_user:
[	!User_Password(user_name, account_name, pw, EMSP_Name) ] 
--[ KeyReveal('LongTermKey_KeyReveal_Password', user_name), KeyReveal('LongTermKey_KeyReveal_Password', account_name) ]->
[	Out(pw) ]
rule LongTermKey_KeyReveal_Password_emsp:
[	!User_Password(user_name, account_name, pw, EMSP_Name) ] 
--[ KeyReveal('LongTermKey_KeyReveal_Password', EMSP_Name)]->
[	Out(pw) ]

/******************************************/
// LE Secure Connections pairing phase 1
/******************************************/

/******************************************/
// LE Secure Connections pairing phase 2
/******************************************/


/******************************************/
// Authentication stage 1 â€“ Num Comp
/******************************************/

rule User_Agent_connects_to_EV3_secure:
let
	IOcapA = <'IO_Yes', 'OOB_No', 'AuthReq_MITM', 'etc'> 
	PKa = 'g'^~SKa
	BLE_PKa = <$user_name, $device_name, IOcapA, PKa, ~Na>

	IOcapB_OOB = fst(snd(IOcapB))
in
[ 
	Fr(~SKa),
	Fr(~Na) //early Na for simplicity 
] 
--[
	// Verifications
	// Eq(IOcapB_OOB, 'OOB_Yes'), // Authentication Requirements Error otherwise
	NEq($user_name, $device_name),

	// Correctness events
	User_Agent_connects_to_EV3(),
	User_Agent_connects_to_EV3_SK($user_name, $device_name, ~SKa),
	User_Agent_connects_to_EV3_s(PKa),
	BT_SessionKey(~SKa),
	OnlyOnce_Correctness('User_Agent_connects_to_EV3')
]->
[	
	Out( BLE_PKa ),
	User_Agent_State3($user_name, $device_name, $reg_endpoint, IOcapA, ~SKa, ~Na)
]


rule User_Agent_connects_to_EV4:
let
	BLE_PKa = <$user_name, $device_name, IOcapA, PKa, Na>
	
	IOcapB = <'IO_Yes', 'OOB_No', 'AuthReq_MITM', 'etc'> //
	PKb = 'g'^~SKb
	Cb = f4(PKb, PKa, ~Nb, '0')
	BLE_PKb = <$device_name, $user_name, IOcapB, PKb, ~Nb, Cb>

	DHKey = PKa ^ ~SKb
	Vb = g2(PKa, PKb, Na, ~Nb) //numeric comparision
in
[ 
	In( BLE_PKa ), 
	Fr(~Nb),
	EV_State0($device_name, $reg_endpoint, ~SKb)
] 
--[
	// Verifications
	NEq('g', PKa),
	NEq($user_name, $device_name),

	// Correctness events
	User_Agent_connects_to_EV4(DHKey),
	User_Agent_connects_to_EV4_s(DHKey, PKa),
	BT_SessionKey(~SKb),
	OnlyOnce_Correctness('User_Agent_connects_to_EV4')
]->
[	
	Out( BLE_PKb ),
	EV_State4($device_name, $reg_endpoint, $user_name, IOcapA, IOcapB, ~SKb, PKa, DHKey, ~Nb, Na),
	//Out_S_V(<$device_name, $user_name, 'same_device_combination'>),
	Out_S_V(<$device_name, $user_name, Vb, 'numeric_comparision'>) //assuming device confirmation by user
]



/******************************************/
// Authentication stage 2 and long term key calculation
/******************************************/
//IOcapB = <'IO_Yes', 'OOB_No', 'AuthReq_MITM', 'etc.'> //

rule User_Agent_connects_to_EV5:
let
	//Authentication stage 2:
	PKa = 'g'^~SKa
	A = $user_name
	B = $device_name

	BLE_PKb = <$device_name, $user_name, IOcapB, PKb, Nb, Cb>
	Cb_prime = f4(PKb, PKa, Nb, '0')	
	DHKey = PKb ^ ~SKa

	MacKey_LTK = f5(DHKey, ~Na, Nb, A, B, '0', '1', 'btle', '6C888391_AAF5A538_60370BDB_5A6083BE')
	MacKey = fst(MacKey_LTK)
	LTK = snd(MacKey_LTK)

	Va = g2(PKa, PKb, ~Na, Nb) //numeric comparision

	rb = '0'
	Ea = f6(MacKey, ~Na, Nb, rb, IOcapA, A, B) //
	BLE_Ea = <$user_name, $device_name, Ea>
in
[ 
	User_Agent_State3($user_name, $device_name, $reg_endpoint, IOcapA, ~SKa, ~Na),
	In( BLE_PKb ),
	In_S_V(<$device_name, $user_name, Vb, 'numeric_comparision'>) //assuming device confirmation by user
] 
--[
	// Verifications
	NEq('g', PKb),
	Eq(Cb, Cb_prime),
	Eq(Va, Vb),

	// Correctness events
	User_Agent_connects_to_EV5(DHKey),
	User_Agent_connects_to_EV5_LTK($user_name, $device_name, LTK),
	User_Agent_connects_to_EV5_SK($user_name, $device_name, ~SKa),
	OnlyOnce_Correctness('User_Agent_connects_to_EV5'),

	//Authentication events
	RunningUA_EV($user_name, $device_name, <Nb, ~Na>)
]->
[	
	Out(BLE_Ea),
	User_Agent_State10($user_name, $device_name, $reg_endpoint, IOcapA, IOcapB, ~SKa, PKb, DHKey, ~Na, Nb, MacKey, LTK)
]


rule User_Agent_connects_to_EV11:
let
	PKb = 'g'^~SKb
	A = $user_name
	B = $device_name

	BLE_Ea = <$user_name, $device_name, Ea>

	MacKey_LTK = f5(DHKey, Na, ~Nb, A, B, '0', '1', 'btle', '6C888391_AAF5A538_60370BDB_5A6083BE')
	MacKey = fst(MacKey_LTK)
	LTK = snd(MacKey_LTK)
	Eb = f6(MacKey, ~Nb, Na, '0', IOcapB, B, A) //ra = 0
	BLE_Eb = <$device_name, $user_name, Eb>

	rb = '0'
	Ea_prime = f6(MacKey, Na, ~Nb, rb, IOcapA, A, B) //
in
[ 
	In(BLE_Ea),
	EV_State4($device_name, $reg_endpoint, $user_name, IOcapA, IOcapB, ~SKb, PKa, DHKey, ~Nb, Na)
] 
--[
	// Verifications
	Eq(Ea, Ea_prime), 

	// Correctness events
	User_Agent_connects_to_EV11(),
	OnlyOnce_Correctness('User_Agent_connects_to_EV11'),
	User_Agent_connects_to_EV11_s(LTK, DHKey),
	User_Agent_connects_to_EV11_LTK($device_name, $user_name, LTK),

	//Authentication events
	RunningEV_UA($device_name, $user_name, <Na, ~Nb>),
	CommitEV_UA($device_name, $user_name, <~Nb, Na>),
	CommitEV_UA_LTK($device_name, $user_name, LTK),
	Honest($user_name),
	Honest($device_name)
]->
[	
	Out(BLE_Eb),
	!EV_State11($device_name, $reg_endpoint, $user_name, LTK) 
]

rule User_Agent_connects_to_EV12:
let
	A = $user_name
	B = $device_name
	BLE_Eb = <$device_name, $user_name, Eb>

	Eb_prime = f6(MacKey, Nb, ~Na, '0', IOcapB, B, A) //ra = 0
in
[ 
	In(BLE_Eb),
	User_Agent_State10($user_name, $device_name, $reg_endpoint, IOcapA, IOcapB, ~SKa, PKb, DHKey, ~Na, Nb, MacKey, LTK)
] 
--[
	// Verifications
	Eq(Eb, Eb_prime), 
	
	// Correctness events
	User_Agent_connects_to_EV12(),
	OnlyOnce_Correctness('User_Agent_connects_to_EV12'),
	BT_LTK(LTK),

	//Authentication events
	CommitUA_EV($user_name, $device_name, <~Na, Nb>),
	CommitUA_EV_LTK($user_name, $device_name, LTK),
	Honest($user_name),
	Honest($device_name)
]->
[	
	!User_Agent_State12($user_name, $device_name, $reg_endpoint, LTK)
]



/******************************************/
// 3. User Agent prepares PnC Registration
/******************************************/
/*
rule User_Agent_prepares_PnC_Registration1:
let
	req_emsp_list = <$user_ip, $reg_endpoint, 'req_emsp_list'>
	req_emsp_list_bt = <$user_name, $device_name, senc(req_emsp_list, LTK)>
in
[ 
	!User_Agent_State12($user_name, $device_name, $reg_endpoint, LTK)
] 
--[
	//OnlyOnce('User_Agent_prepares_PnC_Registration1'),

	// Correctness events
	User_Agent_prepares_PnC_Registration1(),
	OnlyOnce_Correctness('User_Agent_prepares_PnC_Registration1'),

	User_Agent_prepares_PnC_Registration1_s(senc(req_emsp_list, LTK), LTK)
]->
[	
	Out(req_emsp_list_bt),
	User_Agent_State_reg1($user_name, $device_name, $reg_endpoint, LTK, $user_ip)
]
*/


rule User_Agent_prepares_PnC_Registration3:
//let
	//res_emsp_list = <$reg_endpoint, $user_ip, 'res_emsp_list', $emsp_endpoint1, $emsp_endpoint2>
	//res_emsp_list_bt = <$device_name, $user_name, enc_res_emsp_list>
//in
[ 
	!User_Agent_State12($user_name, $device_name, $reg_endpoint, LTK),
	//User_Agent_State_reg1($user_name, $device_name, $reg_endpoint, LTK, $user_ip),
	!EMSP_Pk( $emsp_endpoint1, EMSP_PK1 ),
	!EMSP_Pk( $emsp_endpoint2, EMSP_PK2 )
	//In(res_emsp_list_bt)
] 
--[
	// Verifications
	NEq($emsp_endpoint1, $user_name),
	NEq($emsp_endpoint2, $user_name),
	NEq($emsp_endpoint1, $emsp_endpoint2),

	// Correctness events
	User_Agent_prepares_PnC_Registration3(),
	OnlyOnce_Correctness('User_Agent_prepares_PnC_Registration3')
]->
[	
	User_Agent_State_reg3($user_name, $device_name, $reg_endpoint, LTK, $user_ip, $emsp_endpoint1, $emsp_endpoint2),
	Out_S_V(<$user_name, $device_name, $emsp_endpoint1, $emsp_endpoint2, 'emsp_selection'>)
]

/******************************************/
// 4. User selects eMSP and 5. User adjusts Contract
/******************************************/
//multiset to shuffle
//parameters should be authentic


//select emsp1
rule User_selects_eMSP1_1:
[ 
	In_S_V(<$user_name, $device_name, emsp_endpoint1, emsp_endpoint2, 'emsp_selection'>)
] 
--[
	// Correctness events
	User_selects_eMSP1(),
	OnlyOnce_Correctness('User_selects_eMSP1')
]->
[	
	Out_S_V(<$user_name, $device_name, emsp_endpoint1, $contract_params, 'contract_params'>),
	User_State_sel1($user_name, $device_name, emsp_endpoint1, $contract_params)
]

rule User_selects_eMSP1_2:
[ 
	User_Agent_State_reg3($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpoint1, emsp_endpoint2),
	In_S_V(<$user_name, $device_name, emsp_endpoint1, $contract_params, 'contract_params'>)
] 
--[
	// Correctness events
	User_selects_eMSP2(),
	OnlyOnce_Correctness('User_selects_eMSP2')
]->
[	
	User_Agent_State_sel1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpoint1, $contract_params)
]

//select emsp2
rule User_selects_eMSP2_1:
[ 
	In_S_V(<$user_name, $device_name, emsp_endpoint1, emsp_endpoint2, 'emsp_selection'>)
] 
--[
	// Correctness events
	User_selects_eMSP1(),
	OnlyOnce_Correctness('User_selects_eMSP1')
]->
[	
	Out_S_V(<$user_name, $device_name, emsp_endpoint2, $contract_params, 'contract_params'>),
	User_State_sel1($user_name, $device_name, emsp_endpoint2, $contract_params)
]

rule User_selects_eMSP2_2:
[ 
	User_Agent_State_reg3($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpoint1, emsp_endpoint2),
	In_S_V(<$user_name, $device_name, emsp_endpoint2, $contract_params, 'contract_params'>)
] 
--[
	// Correctness events
	User_selects_eMSP2(),
	OnlyOnce_Correctness('User_selects_eMSP2')
]->
[	
	User_Agent_State_sel1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpoint2, $contract_params)
]

/******************************************/
// 6. Request Contract Provisioning
/******************************************/

rule Request_Contract_Provisioning1:
let
	req_cont_prov = <$user_ip, $reg_endpoint, 'req_cont_prov', emsp_endpointX, $contract_params>
	req_cont_prov_bt = <$user_name, $device_name, senc(req_cont_prov, LTK)>
in
[ 
	User_Agent_State_sel1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpointX, $contract_params)
] 
--[
	// Correctness events
	Request_Contract_Provisioning1(),
	OnlyOnce_Correctness('Request_Contract_Provisioning1')
]->
[	
	User_Agent_State_prov1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpointX, $contract_params),
	Out(req_cont_prov_bt)
]

//emsp1
rule Request_Contract_Provisioning2:
let
	//req_cont_prov = <$user_ip, $reg_endpoint, 'req_cont_prov', emsp_endpointX, $contract_params>
	req_cont_prov_bt = <$user_name, $device_name, enc_req_cont_prov>
	req_cont_prov = sdec(enc_req_cont_prov, LTK)

	user_ip_in = fst(req_cont_prov)
	reg_endpoint_in = fst(snd(req_cont_prov))
	req_cont_prov_tag = fst(snd(snd(req_cont_prov)))
	emsp_endpoint1 = fst(snd(snd(snd(req_cont_prov))))
	contract_params = snd(snd(snd(snd(req_cont_prov))))
in
[ 
	!EV_State11($device_name, $reg_endpoint, $user_name, LTK),
	In(req_cont_prov_bt)
] 
--[
	// Verifications
	Eq($reg_endpoint, reg_endpoint_in), 
	Eq(req_cont_prov_tag, 'req_cont_prov'), 
	NEq(emsp_endpoint1, $device_name),

	// Correctness events
	Request_Contract_Provisioning2(),
	OnlyOnce_Correctness('Request_Contract_Provisioning2')
]->
[	
	EV_State_prov1($device_name, $reg_endpoint, $user_name, LTK, user_ip_in, emsp_endpoint1, contract_params)
]


/******************************************/
// 7. EV prepares Token Request and 8. EV generates Contract Certificate Request Token and
// 9. EV sends Request to eMSP and 10. eMSP responds with Request URI and
// 11. EV responds to User Agent with Request URI
/******************************************/

rule EV_prepares_Token_Request1: //now: Device Authorization Request
let
	authorization_details = <$emsp_endpointX, contract_params, $device_name> 
	
	OAuth_PK = pk(~OAuth_SK)
	private_key_jwt_tbs = <$OEM_Name, $device_name, $emsp_endpointX, ~jti, $exp, $iat, OAuth_PK>
	private_key_jwt = <private_key_jwt_tbs, sign(private_key_jwt_tbs, ~OAuth_SK)>

	oauth_push = <'device_authorization', private_key_jwt, $scope, authorization_details> // client_id=oem-app=real ID?
in
[ 
	EV_State_prov1($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params),
	!OEM_OAuth_Sk( $OEM_Name, $device_name, ~OAuth_SK ),
	!EMSP_Pk( $emsp_endpointX, EMSP_PK ),
	Fr(~jti),
	Fr(~TLS_Key_EV) //simplified TLS setup; allows spoofing of client
] 
--[
	// Correctness events
	EV_prepares_Token_Request1(),
	OnlyOnce_Correctness('EV_prepares_Token_Request1')

	//Authentication events
	//RunningEV_EMSP_code_verifier($EV_pub_endpoint, $emsp_endpointX, ~code_verifier)
]->
[	
	Out(<$EV_pub_endpoint, $emsp_endpointX, senc(oauth_push, ~TLS_Key_EV), aenc(~TLS_Key_EV, EMSP_PK)>),
	EV_State_tok1($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~TLS_Key_EV)
]

rule EV_prepares_Token_Request2:
let
	authorization_details = <emsp_endpointX_in2, contract_params, $device_name>
	private_key_jwt_tbs = <$OEM_Name, $device_name, $emsp_endpointX, jti, exp, iat, OAuth_PK>
	private_key_jwt = <private_key_jwt_tbs, private_key_jwt_sig>
	oauth_push = <'device_authorization', private_key_jwt, $scope, authorization_details>

	device_authorization_res = <'device_authorization_res', ~device_code, ~user_code, $verification_uri>

	TLS_Key_EV = adec(enc_TLS_Key_EV, ~EMSP_SK)
in
[ 
	!EMSP_Sk( $emsp_endpointX, ~EMSP_SK ),
	!OEM_OAuth_Pk( $OEM_Name, $device_name, OAuth_PK ), //via an OpenID Federation that the identity provider trusts.
	In(<$EV_pub_endpoint, emsp_endpointX_in1, senc(oauth_push, TLS_Key_EV), enc_TLS_Key_EV>),
	Fr(~device_code),
	Fr(~user_code)
] 
--[
	// Verifications
	Eq($emsp_endpointX, emsp_endpointX_in1), 
	Eq($emsp_endpointX, emsp_endpointX_in2), 
	OnlyOnce(<'EMSP_EV', TLS_Key_EV>), //provided by TLS
	OnlyOnce(<'EMSP_nonce_OAuth_PK', OAuth_PK, jti>), //unique nonce that the identity provider remembers for the validity period of the JWT
	Eq(verify(private_key_jwt_sig, private_key_jwt_tbs, OAuth_PK), true), 

	// Correctness events
	EV_prepares_Token_Request2(),
	OnlyOnce_Correctness('EV_prepares_Token_Request2'),

	EV_prepares_Token_Request2_dev_auth($emsp_endpointX, <'device_authorization_res', ~device_code, ~user_code, $verification_uri>)
]->
[	
	Out(<$emsp_endpointX, $EV_pub_endpoint, senc(device_authorization_res, TLS_Key_EV)>),
	EMSP_State_tok1($emsp_endpointX, $EV_pub_endpoint, oauth_push, ~device_code, ~user_code, $verification_uri, $device_name, TLS_Key_EV)
]

rule EV_prepares_Token_Request3:
let
	device_authorization_res = <'device_authorization_res', ~device_code, ~user_code, $verification_uri>

	emsp_req_uri = <$reg_endpoint, user_ip, 'verification_uri', $emsp_endpointX, ~user_code, $verification_uri>
	emsp_req_uri_bt = <$device_name, $user_name, senc(emsp_req_uri, LTK)>
in
[ 
	In(<$emsp_endpointX, $EV_pub_endpoint, senc(device_authorization_res, ~TLS_Key_EV)>),
	EV_State_tok1($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~TLS_Key_EV)
]
--[
	// Correctness events
	EV_prepares_Token_Request3(),
	OnlyOnce_Correctness('EV_prepares_Token_Request3'),

	EV_prepares_Token_Request3_dev_auth($emsp_endpointX, <'device_authorization_res', ~device_code, ~user_code, $verification_uri>)
]->
[	
	Out(emsp_req_uri_bt),
	Out_S_V(<$device_name, $device_name, 'ev_device_name', ~user_code>),
	EV_State_tok3($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~TLS_Key_EV, ~device_code, ~user_code)
]


/******************************************/
// 12. User Agent start Authorization Request and 13. eMSP's AS authenticates User and
// 14. User authorizes the Charging Contract and 15. Authorization Response and
// 16. User Agent forwards Authorization Code to EV
/******************************************/

rule User_Agent_starts_Authorization_Request1:
let
	//emsp_req_uri = <$reg_endpoint, user_ip, 'emsp_req_uri', $emsp_endpointX, $verification_uri>
	//emsp_req_uri = <$reg_endpoint, user_ip, 'verification_uri', $emsp_endpointX, ~user_code, $verification_uri>
	emsp_req_uri_bt = <$device_name, $user_name, enc_emsp_req_uri>
	emsp_req_uri = sdec(enc_emsp_req_uri, LTK)

	reg_endpoint_in = fst(emsp_req_uri)
	user_ip_in = fst(snd(emsp_req_uri))
	emsp_req_uri_tag = fst(snd(snd(emsp_req_uri)))
	emsp_endpointX_in = fst(snd(snd(snd(emsp_req_uri))))
	user_code = fst(snd(snd(snd(snd(emsp_req_uri)))))
	verification_uri = snd(snd(snd(snd(snd(emsp_req_uri)))))
in
[ 
	User_Agent_State_prov1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpointX, $contract_params),
	In(emsp_req_uri_bt),
	!User_Password($user_name, $account_name, ~pw, emsp_endpointX),
	!EMSP_Pk( emsp_endpointX, EMSP_PK ),
	Fr(~TLS_Key_UA) //simplified TLS setup; allows spoofing of client
]
--[
	// Verifications
	Eq($reg_endpoint, reg_endpoint_in), 
	Eq($user_ip, user_ip_in), 
	Eq(emsp_req_uri_tag, 'verification_uri'), 
	Eq(emsp_endpointX, emsp_endpointX_in), 

	// Correctness events
	User_Agent_starts_Authorization_Request1(),
	OnlyOnce_Correctness('User_Agent_starts_Authorization_Request1'),

	//Authentication events
	RunningUser_EMSP_TLS($account_name, emsp_endpointX, ~TLS_Key_UA)
]->
[
	User_Agent_State_auth1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpointX, $contract_params, verification_uri, ~TLS_Key_UA, $account_name, user_code),
	Out(<$user_ip, <emsp_endpointX, verification_uri>, senc(<'Authorization_Request', $account_name, ~pw, user_code>, ~TLS_Key_UA), aenc(~TLS_Key_UA, EMSP_PK)>) //
]

rule User_Agent_starts_Authorization_Request2:
let
	authorization_details = <$emsp_endpointX, contract_params, $device_name>
	oauth_push = <'device_authorization', private_key_jwt, $scope, authorization_details>

	TLS_Key_UA = adec(enc_TLS_Key_UA, ~EMSP_SK)
in
[ 
	!EMSP_Sk( $emsp_endpointX, ~EMSP_SK ),
	!User_Password(user_name_NA, account_name, pw, $emsp_endpointX),
	EMSP_State_tok1($emsp_endpointX, $EV_pub_endpoint, oauth_push, ~device_code, ~user_code, $verification_uri, $device_name, TLS_Key_EV),
	In(<user_ip, <$emsp_endpointX, $verification_uri>, senc(<'Authorization_Request', account_name, pw, user_code_in>, TLS_Key_UA), enc_TLS_Key_UA>)
]
--[
	// Verifications
	Eq(~user_code, user_code_in), 

	OnlyOnce(<'EMSP_UA', TLS_Key_UA>), //provided by TLS
	// Correctness events
	User_Agent_starts_Authorization_Request2(),
	OnlyOnce_Correctness('User_Agent_starts_Authorization_Request2'),

	//Authentication events
	CommitEMSP_User_TLS($emsp_endpointX, account_name, TLS_Key_UA),
	Honest($emsp_endpointX),
	Honest(account_name),
	Honest(user_ip),

	//Authentication events
	RunningEMSP_EV_auth($emsp_endpointX, $device_name, ~device_code),
	RunningEMSP_User_auth($emsp_endpointX, account_name, ~user_code),
	RunningEMSP_User_auth2($emsp_endpointX, account_name, <$device_name, ~user_code>)
]->
[
	EMSP_State_auth1($emsp_endpointX, $EV_pub_endpoint, oauth_push, $verification_uri, user_ip, TLS_Key_EV, ~device_code, account_name),
	Out(<$emsp_endpointX, user_ip, senc(<'Authorization_Response', authorization_details>, TLS_Key_UA)>)	
]

rule User_Agent_starts_Authorization_Request3:
let
	authorization_details = <emsp_endpointX, $contract_params, $device_name>
in
[ 
	User_Agent_State_auth1($user_name, $device_name, $reg_endpoint, LTK, $user_ip, emsp_endpointX, $contract_params, verification_uri, ~TLS_Key_UA, $account_name, user_code),
	User_State_sel1($user_name, $device_name, emsp_endpointX, $contract_params),
	In(<emsp_endpointX, $user_ip, senc(<'Authorization_Response', authorization_details>, ~TLS_Key_UA)>)	
]
--[
	BT_LTK(LTK),

	// Correctness events
	User_Agent_starts_Authorization_Request3(),
	OnlyOnce_Correctness('User_Agent_starts_Authorization_Request3'),
	User_Agent_starts_Authorization_Request3_LTK($user_name, $device_name, LTK),

	//Authentication events
	RunningUA_EV_user_code($user_name, $device_name, <emsp_endpointX, user_code>),
	RunningUA_EV_user_code3($user_name, $device_name, <user_code>),
	CommitUser_EMSP_auth($account_name, emsp_endpointX, user_code),
	CommitUser_EMSP_auth2($account_name, emsp_endpointX, <$device_name, user_code>),
	Honest(emsp_endpointX),
	Honest($user_name),
	Honest($account_name),
	Honest($user_ip)
	// CommitEV_EMSP_auth_code($device_name, emsp_endpointX, authorization_code),
	// Honest($device_name),
	// Honest($device_name)
]->
[
	//Out_S_V(<$user_name, $device_name, $contract_params, 'user_contract_params', user_code>),
	Out(<$user_ip, <emsp_endpointX, verification_uri>, senc(<'Authorization_Grant', $account_name, $device_name>, ~TLS_Key_UA)>) // VIN check assumed by same device_name
]




/******************************************/
// 17. Token Request
/******************************************/

rule Token_Request1:
let
	//redirect_auth = <$user_ip, $reg_endpoint, 'redirect_auth', authorization_code>

	OAuth_PK = pk(~OAuth_SK)
	private_key_jwt2_tbs = <$OEM_Name, $device_name, $emsp_endpointX, ~jti, $exp, $iat, OAuth_PK>
	private_key_jwt2 = <private_key_jwt2_tbs, sign(private_key_jwt2_tbs, ~OAuth_SK)>

	device_access_token_req = <'device_access_token_req', private_key_jwt2, device_code>
in
[ 
	EV_State_tok3($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~TLS_Key, device_code, user_code),
	!OEM_OAuth_Sk( $OEM_Name, $device_name, ~OAuth_SK ),
	//In_S_V(<$user_name, $device_name, user_code, 'device_nameOK'>),
	Fr(~jti)
]
--[
	//OnlyOnce('Token_Request1'),
	// Correctness events
	Token_Request1(),
	Token_Request1_LTK($device_name, $user_name, LTK),
	Token_Request1_device_access_token_req($EV_pub_endpoint, $emsp_endpointX, device_access_token_req),
	OnlyOnce_Correctness('Token_Request1'),

	BT_LTK(LTK),

	//Authentication events
	//RunningEV_EMSP_code_verifier($EV_pub_endpoint, $emsp_endpointX, ~code_verifier),
	RunningEV_EMSP_auth_dev($device_name, $emsp_endpointX, device_code),
	//Authentication events
	CommitEV_UA_user_code($device_name, $user_name, <$emsp_endpointX, user_code>),
	CommitEV_UA_user_code3($device_name, $user_name, <user_code>),
	CommitEV_EMSP_auth($device_name, $emsp_endpointX, device_code),
	Honest($emsp_endpointX),
	Honest($EV_pub_endpoint),
	Honest($device_name),
	Honest($user_name) //no pw leak
]->
[
	Out(<$EV_pub_endpoint, $emsp_endpointX, senc(device_access_token_req, ~TLS_Key)>),
	EV_State_tokReq1($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~TLS_Key)
]


rule Token_Request2:
let
	authorization_details = <emsp_endpointX_in, contract_params, device_name>

	private_key_jwt_tbs = <$OEM_Name, device_name, $emsp_endpointX, jti, exp, iat, OAuth_PK>
	private_key_jwt = <private_key_jwt_tbs, private_key_jwt_sig>
	oauth_push = <'device_authorization', private_key_jwt, $scope, authorization_details>

	private_key_jwt2_tbs = <$OEM_Name, device_name, $emsp_endpointX, jti2, exp, iat, OAuth_PK>
	private_key_jwt2 = <private_key_jwt2_tbs, private_key_jwt2_sig>
	device_access_token_req = <'device_access_token_req', private_key_jwt2, device_code_in>
	
in
[ 
	EMSP_State_auth1($emsp_endpointX, $EV_pub_endpoint, oauth_push, $verification_uri, user_ip, TLS_Key, ~device_code, account_name),
	In(<user_ip, <$emsp_endpointX, $verification_uri>, senc(<'Authorization_Grant', account_name, device_name>, TLS_Key_UA)>),
	//EMSP_State_auth6($emsp_endpointX, $EV_pub_endpoint, oauth_push, $verification_uri, user_ip, ~authorization_code, TLS_Key),
	In(<$EV_pub_endpoint, $emsp_endpointX, senc(device_access_token_req, TLS_Key)>),
	!OEM_OAuth_Pk( $OEM_Name, device_name, OAuth_PK ), //via an OpenID Federation that the identity provider trusts.
	Fr(~access_token)
]
--[
	// Verifications
	Eq(~device_code, device_code_in), 
	//Eq(h(code_verifier), code_challenge), 
	Eq(verify(private_key_jwt2_sig, private_key_jwt2_tbs, OAuth_PK), true), 
	OnlyOnce(<'EMSP_nonce_OAuth_PK', OAuth_PK, jti2>), //unique nonce that the identity provider remembers for the validity period of the JWT

	// Correctness events
	Token_Request2(),
	Token_Request2_device_access_token_req($EV_pub_endpoint, $emsp_endpointX, device_access_token_req),
	OnlyOnce_Correctness('Token_Request2'),

	//Authentication events
	//CommitEMSP_EV_code_verifier($emsp_endpointX, $EV_pub_endpoint, code_verifier),
	CommitEMSP_EV_auth_dev($emsp_endpointX, device_name, ~device_code),
	Honest($emsp_endpointX),
	Honest($EV_pub_endpoint),
	Honest(device_name),
	Honest(account_name)
]->
[
	Out(<$emsp_endpointX, $EV_pub_endpoint, senc(<'access_token', device_name, ~access_token>, TLS_Key)>),
	EMSP_State_tokReq2($emsp_endpointX, $EV_pub_endpoint, oauth_push, $verification_uri, user_ip, device_name, ~access_token, TLS_Key, ~device_code, account_name)
]


//TODO: optional Provisioning Key Sig...
rule Token_Request3:
let
	PKev = pk(~SKev)
	attributes = <$emsp_endpointX, $device_name, access_token>
	ccsr_tbs = <'ccsr', PKev, $ccsr_data, attributes>
	ccsr = <ccsr_tbs, sign(ccsr_tbs, ~SKev)>
in
[ 
	In(<$emsp_endpointX, $EV_pub_endpoint, senc(<'access_token', device_name_in, access_token>, ~TLS_Key)>),
	Fr(~SKev),
	EV_State_tokReq1($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~TLS_Key)
]
--[
	// Verifications
	Eq($device_name, device_name_in), 

	// Correctness events
	Token_Request3(),
	OnlyOnce_Correctness('Token_Request3'),
	Token_Request3_access_token($EV_pub_endpoint, $emsp_endpointX, <'access_token', device_name_in, access_token>),
	BT_LTK(LTK),
	Token_Request3_cert_req($EV_pub_endpoint, $emsp_endpointX, <'cert_req', access_token, $device_name, ccsr>),

	//Authentication events
	RunningEV_EMSP($device_name, $emsp_endpointX, PKev),
	RunningEV_EMSP2($EV_pub_endpoint, $emsp_endpointX, PKev),
	RunningEV_EMSP_access_token($EV_pub_endpoint, $emsp_endpointX, access_token)
]->
[
	Out(<$EV_pub_endpoint, $emsp_endpointX, senc(<'cert_req', access_token, $device_name, ccsr>, ~TLS_Key)>),
	EV_State_tokReq3($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~SKev, ~TLS_Key)
]


rule Token_Request4:
let
	authorization_details = <emsp_endpointX_in, contract_params, device_name>
	oauth_push = <'device_authorization', private_key_jwt, $scope, authorization_details>
	
	attributes = <$emsp_endpointX, device_name, access_token_in>
	ccsr_tbs = <'ccsr', PKev, ccsr_data, attributes>
	ccsr = <ccsr_tbs, sign_ccsr_tbs>

	contract_cert_tbs = <'contract_cert', $emsp_endpointX, $EMAID, PKev>
	contract_cert = <contract_cert_tbs, sign(contract_cert_tbs, ~EMSP_SK)>
in
[ 
	EMSP_State_tokReq2($emsp_endpointX, $EV_pub_endpoint, oauth_push, $verification_uri, user_ip, device_name, ~access_token, TLS_Key, ~device_code, account_name),
	!EMSP_Sk( $emsp_endpointX, ~EMSP_SK ),
	In(<$EV_pub_endpoint, $emsp_endpointX, senc(<'cert_req', access_token_in, device_name_in, ccsr>, TLS_Key)>)
]
--[
	// Verifications
	Eq(device_name, device_name_in), 
	Eq(~access_token, access_token_in), 
	Eq(verify(sign_ccsr_tbs, ccsr_tbs, PKev), true), 

	//OnlyOnce(<'EMSP_CC', PKev>), //

	// Correctness events
	Token_Request4(),
	OnlyOnce_Correctness('Token_Request4'),
	Token_Request4_cert_req($EV_pub_endpoint, $emsp_endpointX, <'cert_req', access_token_in, device_name_in, ccsr>),
	TLS_Key($emsp_endpointX, TLS_Key),

	//Authentication events
	CommitEMSP_EV($emsp_endpointX, device_name, PKev),
	CommitEMSP_EV2($emsp_endpointX, $EV_pub_endpoint, PKev),
	CommitEMSP_EV_access_token($emsp_endpointX, $EV_pub_endpoint, ~access_token),
	Honest($emsp_endpointX),
	Honest($EV_pub_endpoint),
	Honest(device_name),
	Honest(account_name), //no pw leak
	
	//Authentication events
	RunningEMSP_EV_CC($emsp_endpointX, device_name, contract_cert_tbs)
]->
[
	Out(<$emsp_endpointX, $EV_pub_endpoint, senc(<'contract_cert', contract_cert>, TLS_Key)>)
]

rule Token_Request5:
let
	PKev = pk(~SKev)
	contract_cert_tbs = <'contract_cert', $emsp_endpointX, $EMAID, PKev>
	contract_cert = <contract_cert_tbs, sign_contract_cert_tbs>
in
[ 
	EV_State_tokReq3($device_name, $reg_endpoint, $user_name, LTK, user_ip, $emsp_endpointX, contract_params, $EV_pub_endpoint, ~SKev, ~TLS_Key),
	!EMSP_Pk( $emsp_endpointX, EMSP_PK ),
	In(<$emsp_endpointX, $EV_pub_endpoint, senc(<'contract_cert', contract_cert>, ~TLS_Key)>)
]
--[
	// Verifications
	Eq(verify(sign_contract_cert_tbs, contract_cert_tbs, EMSP_PK), true), 

	// Correctness events
	Token_Request5(),
	OnlyOnce_Correctness('Token_Request5'),

	//Authentication events
	CommitEV_EMSP_CC($device_name, $emsp_endpointX, contract_cert_tbs),
	Honest($emsp_endpointX),
	Honest($EV_pub_endpoint),
	Honest($device_name),
	Honest($user_name) //no pw leak
]->
[
	//Done
]




// **** lemmas ****

lemma reuse_User_LTK [reuse]:
"
All user_name device_name LTK #i .
User_Agent_starts_Authorization_Request3_LTK(user_name, device_name, LTK) @ i 
	==>
	Ex  #j . 
		User_Agent_connects_to_EV5_LTK(user_name, device_name, LTK) @ j & #j<#i
"
lemma reuse_User_SK [reuse]:
"
All user_name device_name SK #i .
User_Agent_connects_to_EV5_SK(user_name, device_name, SK) @ i 
	==>
	Ex  #j . 
		User_Agent_connects_to_EV3_SK(user_name, device_name, SK) @ j & #j<#i
"


lemma reuse_EV_LTK [reuse]:
"
All user_name device_name LTK #i .
Token_Request1_LTK(device_name, user_name, LTK) @ i 
	==>
	Ex  #j . 
		User_Agent_connects_to_EV11_LTK(device_name, user_name, LTK) @ j & #j<#i
"


/*
lemma reuse_EV_LTK_UA [reuse]:
"
All user_name device_name LTK #i .
Token_Request1_LTK(device_name, user_name, LTK) @ i 
	==>
	Ex  #j . 
		User_Agent_connects_to_EV5_LTK(user_name, device_name, LTK)  @ j & #j<#i
"
*/

/*
lemma reuse_Dev_Auth [reuse]:
"
All emsp data #i .
EV_prepares_Token_Request3_dev_auth(emsp, data) @ i 
	==>
	(Ex  #j . EV_prepares_Token_Request2_dev_auth(emsp, data)  @ j & #j<#i)
	|
	(Ex #kr . KeyReveal('LongTermKey_KeyReveal_EMSP', emsp) @ kr)
"
*/


/*
lemma UA_Auth_code [reuse]:
"
All user_name device_name emsp_endpointX account_name authorization_code #i .
User_Agent_starts_Authorization_Request7_auth_code(user_name, device_name, emsp_endpointX, account_name, authorization_code) @ i 
	==>
	(Ex  #j . 
		User_Agent_starts_Authorization_Request2_authorization_code(emsp_endpointX, account_name, authorization_code) @ j & #j<#i)
	|
	(Ex  #j . 
		KeyReveal('LongTermKey_KeyReveal_EMSP', emsp_endpointX) @ j & #j<#i)
"
lemma EV_Auth_code [reuse]:
"
All user_name device_name emsp_endpointX authorization_code #i .
Token_Request1_auth_code2(device_name, user_name, emsp_endpointX, authorization_code) @ i 
	==>
	Ex  account_name #j . 
		User_Agent_starts_Authorization_Request7_auth_code(user_name, device_name, emsp_endpointX, account_name, authorization_code) @ j & #j<#i
"

lemma EV_Auth_code2 [reuse]:
"
All user_name device_name emsp_endpointX authorization_code #i .
Token_Request1_auth_code2(device_name, user_name, emsp_endpointX, authorization_code) @ i 
	==>
	not (Ex  #j . 
		!KU(authorization_code) @ j)
		|
	(Ex event #j . 
		KeyReveal(event, emsp_endpointX) @ j)
"
*/


lemma correctness_simple6:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15 DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15




	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"

lemma correctness_simple7:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15
	  #i16 #i17 #i18 #i19 #i20 #i21 #i22  DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15

	& User_selects_eMSP1() @i16
	& User_selects_eMSP2() @i17
	& Request_Contract_Provisioning1() @i18
	& Request_Contract_Provisioning2() @i19
	& EV_prepares_Token_Request1() @i20
	& EV_prepares_Token_Request2() @i21
	& EV_prepares_Token_Request3() @i22


	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"

lemma correctness_simple81:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15
	  #i16 #i17 #i18 #i19 #i20 #i21 #i22 #i23
	   DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15

	& User_selects_eMSP1() @i16
	& User_selects_eMSP2() @i17
	& Request_Contract_Provisioning1() @i18
	& Request_Contract_Provisioning2() @i19
	& EV_prepares_Token_Request1() @i20
	& EV_prepares_Token_Request2() @i21
	& EV_prepares_Token_Request3() @i22

	& User_Agent_starts_Authorization_Request1() @i23
	//& User_Agent_starts_Authorization_Request7() @i29



	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"
lemma correctness_simple82:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15
	  #i16 #i17 #i18 #i19 #i20 #i21 #i22 #i23 #i24
	   DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15

	& User_selects_eMSP1() @i16
	& User_selects_eMSP2() @i17
	& Request_Contract_Provisioning1() @i18
	& Request_Contract_Provisioning2() @i19
	& EV_prepares_Token_Request1() @i20
	& EV_prepares_Token_Request2() @i21
	& EV_prepares_Token_Request3() @i22

	& User_Agent_starts_Authorization_Request1() @i23
	& User_Agent_starts_Authorization_Request2() @i24
	//& User_Agent_starts_Authorization_Request7() @i29



	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"
lemma correctness_simple83:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15
	  #i16 #i17 #i18 #i19 #i20 #i21 #i22 #i23 #i24 #i25
	   DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15

	& User_selects_eMSP1() @i16
	& User_selects_eMSP2() @i17
	& Request_Contract_Provisioning1() @i18
	& Request_Contract_Provisioning2() @i19
	& EV_prepares_Token_Request1() @i20
	& EV_prepares_Token_Request2() @i21
	& EV_prepares_Token_Request3() @i22

	& User_Agent_starts_Authorization_Request1() @i23
	& User_Agent_starts_Authorization_Request2() @i24
	& User_Agent_starts_Authorization_Request3() @i25
	//& User_Agent_starts_Authorization_Request7() @i29



	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"
lemma correctness_simple8:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15
	  #i16 #i17 #i18 #i19 #i20 #i21 #i22 #i23 #i24 #i25
	   DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15

	& User_selects_eMSP1() @i16
	& User_selects_eMSP2() @i17
	& Request_Contract_Provisioning1() @i18
	& Request_Contract_Provisioning2() @i19
	& EV_prepares_Token_Request1() @i20
	& EV_prepares_Token_Request2() @i21
	& EV_prepares_Token_Request3() @i22

	& User_Agent_starts_Authorization_Request1() @i23
	& User_Agent_starts_Authorization_Request2() @i24
	& User_Agent_starts_Authorization_Request3() @i25
	//& User_Agent_starts_Authorization_Request7() @i29



	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"

lemma correctness_simple9:
exists-trace
" Ex  #i0 #i3 #i4 #i5 #i11 #i12 #i15
	  #i16 #i17 #i18 #i19 #i20 #i21 #i22 #i23 #i24 #i25 
	  #i30 #i31 #i32 #i33 #i34 DHKey1 DHKey2 .
	EV_starts_Setup() @i0
	& User_Agent_connects_to_EV3() @i3
	& User_Agent_connects_to_EV4(DHKey1) @i4
	& User_Agent_connects_to_EV5(DHKey2) @i5
	& User_Agent_connects_to_EV11() @i11
	& User_Agent_connects_to_EV12() @i12
	& User_Agent_prepares_PnC_Registration3() @i15

	& User_selects_eMSP1() @i16
	& User_selects_eMSP2() @i17
	& Request_Contract_Provisioning1() @i18
	& Request_Contract_Provisioning2() @i19
	& EV_prepares_Token_Request1() @i20
	& EV_prepares_Token_Request2() @i21
	& EV_prepares_Token_Request3() @i22

	& User_Agent_starts_Authorization_Request1() @i23
	& User_Agent_starts_Authorization_Request2() @i24
	& User_Agent_starts_Authorization_Request3() @i25
	//& User_Agent_starts_Authorization_Request7() @i29

	& Token_Request1() @i30
	& Token_Request2() @i31
	& Token_Request3() @i32
	& Token_Request4() @i33
	& Token_Request5() @i34


	& DHKey1=DHKey2
	// The protocol rules are only executed once
	& ( All event #i #j . 
		OnlyOnce_Correctness(event) @i 
		& OnlyOnce_Correctness(event) @j 
		==> #i=#j
	)
	// No entity was corrupted
	& not( Ex event entity #k . 
		KeyReveal(event, entity) @k 
	)
"

/*
lemma auth1_weak_UA_EV:
"
All device_name user_name nonces #i .
	(
		(
			CommitEV_UA(device_name, user_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex nonces2 #j . 
					(
						RunningUA_EV(user_name, device_name, nonces2) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"

lemma auth1_non_inj_UA_EV:
"
All device_name user_name nonces #i .
	(
		(
			CommitEV_UA(device_name, user_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningUA_EV(user_name, device_name, nonces) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"

lemma auth1_inj_UA_EV:
"
All device_name user_name nonces #i .
	(
		(
			CommitEV_UA(device_name, user_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningUA_EV(user_name, device_name, nonces) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex device_name2 user_name2 #i2 . ( CommitEV_UA(device_name2, user_name2, nonces) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
*/

lemma auth2_weak_EV_UA0:
"
All device_name user_name nonces #i .
	(
		(
			CommitUA_EV(user_name, device_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex nonces2 #j . 
					(
						RunningEV_UA(device_name, user_name, nonces2) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr)
		)
	)
"

lemma auth2_weak_EV_UA:
"
All device_name user_name nonces #i .
	(
		(
			CommitUA_EV(user_name, device_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex nonces2 #j . 
					(
						RunningEV_UA(device_name, user_name, nonces2) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"

lemma auth2_non_inj_EV_UA:
"
All device_name user_name nonces #i .
	(
		(
			CommitUA_EV(user_name, device_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEV_UA(device_name, user_name, nonces) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"

lemma auth2_inj_EV_UA:
"
All device_name user_name nonces #i .
	(
		(
			CommitUA_EV(user_name, device_name, nonces) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEV_UA(device_name, user_name, nonces) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex device_name2 user_name2 #i2 . ( CommitUA_EV(device_name2, user_name2, nonces) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"

lemma auth3_non_inj_User_EMSP:
"
All user emsp key #i .
	(
		(
			CommitEMSP_User_TLS(emsp, user, key) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningUser_EMSP_TLS(user, emsp, key) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
lemma auth3_inj_User_EMSP:
"
All user emsp key #i .
	(
		(
			CommitEMSP_User_TLS(emsp, user, key) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningUser_EMSP_TLS(user, emsp, key) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex emsp2 user2 #i2 . ( CommitEMSP_User_TLS(emsp2, user2, key) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"


/*
lemma auth4_non_inj_EMSP_User:
"
All user emsp user_code #i .
	(
		(
			CommitUser_EMSP_auth(user, emsp, user_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_User_auth(emsp, user, user_code) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
*/
/*
lemma auth4_inj_EMSP_User:
"
All user emsp user_code #i .
	(
		(
			CommitUser_EMSP_auth(user, emsp, user_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_User_auth(emsp, user, user_code) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex emsp2 user2 #i2 . ( CommitUser_EMSP_auth(user2, emsp2, user_code) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
*/

/*
lemma auth4_non_inj_EMSP_User2:
"
All user emsp ev_and_user_code #i .
	(
		(
			CommitUser_EMSP_auth2(user, emsp, ev_and_user_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_User_auth2(emsp, user, ev_and_user_code) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
*/

/*
lemma auth4_inj_EMSP_User2:
"
All user emsp ev_and_user_code #i .
	(
		(
			CommitUser_EMSP_auth2(user, emsp, ev_and_user_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_User_auth2(emsp, user, ev_and_user_code) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex user2 emsp2 #i2 . ( CommitUser_EMSP_auth2(user2, emsp2, ev_and_user_code) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
*/

/*
lemma auth4_non_inj_UA_EV3:
"
All ev ua user_code #i .
	(
		(
			CommitEV_UA_user_code3(ev, ua, user_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningUA_EV_user_code3(ua, ev, user_code) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"
*/

/*
lemma auth4_inj_UA_EV3:
"
All ev ua user_code #i .
	(
		(
			CommitEV_UA_user_code3(ev, ua, user_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningUA_EV_user_code3(ua, ev, user_code) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex ev2 ua2 #i2 . ( CommitEV_UA_user_code3(ev2, ua2, user_code) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"*/

/*
lemma auth4_non_inj_EMSP_EV:
"
All ev emsp authorization_code #i .
	(
		(
			CommitEV_EMSP_auth_code(ev, emsp, authorization_code) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_EV_auth_code(emsp, ev, authorization_code) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"*/


lemma auth5_non_inj_EV_EMSP:
"
All emsp device_name PKev #i .
	(
		(
			CommitEMSP_EV(emsp, device_name, PKev) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEV_EMSP(device_name, emsp, PKev) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"


lemma auth5_inj_EV_EMSP:
"
All emsp device_name PKev #i .
	(
		(
			CommitEMSP_EV(emsp, device_name, PKev) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEV_EMSP(device_name, emsp, PKev) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex emsp2 device_name2 #i2 . ( CommitEMSP_EV(emsp2, device_name2, PKev) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"



lemma auth6_non_inj_EMSP_EV_CC:
"
All emsp device_name CC #i .
	(
		(
			CommitEV_EMSP_CC(device_name, emsp, CC) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_EV_CC(emsp, device_name, CC) @ j
						& 
						(#j<#i) 
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"


lemma auth6_inj_EMSP_EV_CC:
"
All emsp device_name CC #i .
	(
		(
			CommitEV_EMSP_CC(device_name, emsp, CC) @ i 
		)
		==>
		(
			(
				(Ex #j . 
					(
						RunningEMSP_EV_CC(emsp, device_name, CC) @ j
						& 
						(#j<#i) 
						&
						( not(
							Ex emsp2 device_name2 #i2 . ( CommitEV_EMSP_CC(device_name2, emsp2, CC) @ i2 & not(#i2=#i) )
							)
						)
					)
				)
			)
			|
			(Ex RevealEvent Entity #kr . KeyReveal(RevealEvent, Entity) @ kr & Honest(Entity) @ i)
		)
	)
"

end
