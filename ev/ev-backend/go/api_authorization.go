/*
 * EV Backend
 *
 * API version: 0.0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package ev_backend

import (
	// "crypto/sha256"
	// "encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"strings"
	"time"
)

var LogWriter *os.File = nil

// type Session struct {
// 	PkceVerifier string
// 	EmspId       string
// 	RedirectUri  string
// }

// var sessions = make(map[string]Session)

// var randomCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// var pkceChallengeCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"

var emspResources map[string]string

var now time.Time
var endTime time.Time
var deviceCode string
var interval uint32
var tokenEndpoint string
var clientId string

func GenerateRandomString(length int, charset string) string {
	random := rand.New(rand.NewSource(time.Now().UnixNano()))
	charsetLength := len(charset)
	result := make([]byte, length)
	for i := range result {
		result[i] = charset[random.Intn(charsetLength)]
	}
	return string(result)
}

func GetEmsp(id string) *Emsp {
	// Search in Emsps for eMSP with matching id.
	for _, emsp := range Emsps {
		if emsp.Id == id {
			return &emsp
		}
	}
	return nil
}

func GetDiscoveryDocument(baseUrl string) (map[string]interface{}, error) {
	// Build Discovery URL
	discoveryUrl := baseUrl + "/.well-known/openid-configuration"

	// Request discovery document
	resp, err := http.Get(discoveryUrl)
	if err != nil {
		return nil, err
	}

	// Read HTTP body
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse HTTP body
	var discoveryDocument map[string]interface{}
	err = json.Unmarshal(body, &discoveryDocument)
	if err != nil {
		return nil, err
	}

	return discoveryDocument, nil
}

// func GetPkce() (string, string, error) {
// 	// Generate random PKCE Verifier
// 	pkceVerifier := GenerateRandomString(128, pkceChallengeCharSet)

// 	// Encode Verifier to ASCII
// 	asciiEncodedVerifier := []byte(pkceVerifier)

// 	// Generate SHA-256 hash from ASCII-encoded verifier
// 	hash := sha256.New()
// 	_, err := hash.Write(asciiEncodedVerifier)
// 	if err != nil {
// 		return "", "", err
// 	}
// 	sha256Verifier := hash.Sum(nil)

// 	// Encode the SHA-256 hash to base64url
// 	pkceChallenge := strings.ReplaceAll(base64.URLEncoding.EncodeToString(sha256Verifier), "=", "")

// 	return pkceVerifier, pkceChallenge, nil
// }

func RequestContractProvisioning(w http.ResponseWriter, r *http.Request) {
	measureStart := time.Now()
	// Parse Contract Provisioning Request body
	var cpr ContractProvisioningRequest
	err := json.NewDecoder(r.Body).Decode(&cpr)
	if err != nil {
		log.Printf("Failed to parse ContractProvisioningRequest")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Search for eMSP with requested ID
	emsp := GetEmsp(cpr.EmspId)
	if emsp == nil {
		log.Printf("Unknown eMSP with ID \"" + cpr.EmspId + "\"")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	emspCreds := GetEmspCredential(emsp.Id)
	if emspCreds == nil {
		log.Printf("Unknown eMSP Credentials with ID \"" + emsp.Id + "\"")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	clientId = emspCreds.ClientId

	// Get discovery document
	discoveryDocument, err := GetDiscoveryDocument(emsp.BaseUrl)
	if err != nil {
		log.Printf("Failed to load discovery document for eMSP with Base URL \"" + emsp.BaseUrl + "\"")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Get device authorization endpoint from discovery document
	deviceAuthorizationEndpoint, found := discoveryDocument["device_authorization_endpoint"].(string)
	if !found {
		log.Printf("eMSP \"" + emsp.BaseUrl + "\" does not support Device Authorization Requests")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// // Prepare PKCE
	// pkceVerifier, pkceChallenge, err := GetPkce()
	// if err != nil {
	// 	log.Printf("Failed to generate PKCE challenge")
	// 	w.WriteHeader(http.StatusInternalServerError)
	// 	return
	// }

	// // Create new session
	// sessionId := GenerateRandomString(20, randomCharSet)
	// sessions[sessionId] = Session{
	// 	PkceVerifier: pkceVerifier,
	// 	EmspId:       emsp.Id,
	// 	RedirectUri:  cpr.RedirectUri,
	// }

	// Get resource server endpoint URL
	resourceEp, found := emspResources[emsp.Id]
	if !found {
		log.Printf("Resource Endpoint not found for client with ID \"" + emsp.Id + "\"")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Encode authorization details:
	authorizationDetailJson := make(map[string]interface{})
	authorizationDetailJson["type"] = "pnc_contract_request"
	authorizationDetailJson["actions"] = [1]string{
		"contract_provisioning",
	}
	authorizationDetailJson["locations"] = [1]string{resourceEp}
	authorizationDetailJson["charging_period"] = *cpr.AuthorizationDetail.ChargingPeriod
	authorizationDetailJson["maximum_amount"] = *cpr.AuthorizationDetail.MaximumAmount
	authorizationDetailJson["maximum_transaction_amount"] = *cpr.AuthorizationDetail.MaximumTransactionAmount
	var authorizationDetailsJson [1]map[string]interface{}
	authorizationDetailsJson[0] = authorizationDetailJson
	authorizationDetails, err := json.Marshal(authorizationDetailsJson)
	if err != nil {
		log.Printf("Failed to serialize authorization details")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Prepare body parameters for Device Authorization Request
	bodyParameters := url.Values{}
	// OAuth Authorization parameters according to RFC 6749:
	bodyParameters.Set("scope", "ccsr")
	bodyParameters.Set("client_id", emspCreds.ClientId)
	// // PKCE parameters according to RFC 7636:
	// bodyParameters.Set("code_challenge", pkceChallenge)
	// bodyParameters.Set("code_challenge_method", "S256")
	// RAR parameters according to RFC 9396:
	bodyParameters.Set("authorization_details", string(authorizationDetails))

	// Encode body parameters to string
	bodyString := bodyParameters.Encode()

	// Send device authorization request
	deviceAuthorizationResponse, err := http.Post(deviceAuthorizationEndpoint, "application/x-www-form-urlencoded", strings.NewReader(bodyString))
	if err != nil {
		log.Printf("Failed to send device authorization request: " + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Read device authorization response body
	defer deviceAuthorizationResponse.Body.Close()
	body, err := io.ReadAll(deviceAuthorizationResponse.Body)
	log.Printf("Received device authorization body: " + string(body))
	if err != nil {
		log.Printf("Failed to read device authorization response: %s", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Parse device authorization response body
	var responseBody DeviceAuthorizationResponseBody
	err = json.Unmarshal(body, &responseBody)
	if err != nil {
		log.Printf("Failed to parse device authorization response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	deviceCode = responseBody.DeviceCode

	now = time.Now()
	log.Printf("Now: " + now.String())
	endTime = time.Now().Add(time.Duration(responseBody.ExpiresIn) * time.Second)
	log.Printf("End time: " + endTime.String())
	interval = responseBody.Interval

	// Create and serialize response
	result := ContractProvisioningResponse{
		UserCode:        responseBody.UserCode,
		VerificationUri: responseBody.VerificationUri,
	}
	resultData, err := json.Marshal(result)
	if err != nil {
		log.Printf("Failed to serialize response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write header and status code
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Write serialized result
	_, err = w.Write(resultData)
	if err != nil {
		log.Printf("Failed to write response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get Token Endpoint from discovery document
	tokenEndpoint, found = discoveryDocument["token_endpoint"].(string)
	if !found {
		log.Printf("eMSP \"" + emsp.BaseUrl + "\" does not support Token Endpoint")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)

	measureEnd := time.Now()
	measureDuration := time.Since(measureStart)
	if LogWriter != nil {
		_, err := LogWriter.WriteString("request_contract_provisioning," + fmt.Sprint(measureStart.UnixNano()) + "," + fmt.Sprint(measureEnd.UnixNano()) + "," + fmt.Sprint(measureDuration.Nanoseconds()) + "\r\n")
		if err != nil {
			log.Printf("Writing measurement failed: " + err.Error())
		}
	}
}

func LoadEmspResourceEps(file string) error {
	// Read emsp resource endpoint file
	data, err := os.ReadFile(file)
	if err != nil {
		return err
	}

	// JSON serialize values
	err = json.Unmarshal(data, &emspResources)
	if err != nil {
		return err
	}

	return nil
}

func ConfirmAuthorization(w http.ResponseWriter, r *http.Request) {
	measureStart := time.Now()

	accessToken := ""

	// Start polling:
	for time.Now().Before(endTime) {
		// Wait for interval
		measureWaitStart := time.Now()
		time.Sleep(time.Duration(interval) * time.Second)
		measureWaitEnd := time.Now()
		measureWaitDuration := time.Since(measureWaitStart)
		if LogWriter != nil {
			_, err := LogWriter.WriteString("waiting," + fmt.Sprint(measureWaitStart.UnixNano()) + "," + fmt.Sprint(measureWaitEnd.UnixNano()) + "," + fmt.Sprint(measureWaitDuration.Nanoseconds()) + "\r\n")
			if err != nil {
				log.Printf("Writing measurement failed: " + err.Error())
			}
		}

		log.Printf("Polling with device code " + deviceCode + "...")

		// Prepare body parameters
		tokenRequestBodyParameters := url.Values{}
		// OAuth Authorization parameters according to RFC 6749:
		tokenRequestBodyParameters.Set("grant_type", "urn:ietf:params:oauth:grant-type:device_code")
		tokenRequestBodyParameters.Set("device_code", deviceCode)
		tokenRequestBodyParameters.Set("client_id", clientId)
		// tokenRequestBodyParameters.Set("client_secret", emspCreds.ClientSecret)
		// // PKCE parameters according to RFC 7636:
		// tokenRequestBodyParameters.Set("code_verifier", session.PkceVerifier)
		// Encode body parameters to string
		tokenRequestBodyString := tokenRequestBodyParameters.Encode()

		// Send Token Request to Token Endpoint.
		tokenRequest, err := http.Post(tokenEndpoint, "application/x-www-form-urlencoded", strings.NewReader(tokenRequestBodyString))
		if err != nil {
			log.Printf("Failed to send Token Request")
			w.WriteHeader(http.StatusInternalServerError)
			continue
		}

		// Read Token response body
		defer tokenRequest.Body.Close()
		tokenResponseBodyString, err := io.ReadAll(tokenRequest.Body)
		if err != nil {
			log.Printf("Failed to read Token response: " + err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			continue
		}

		// Parse Token response body
		var tokenResponseBody map[string]interface{}
		err = json.Unmarshal(tokenResponseBodyString, &tokenResponseBody)
		if err != nil {
			log.Printf("Failed to parse Token response: " + err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			continue
		}

		// Get access token from token response body
		accessTokenData, found := tokenResponseBody["access_token"]
		if !found {
			log.Printf("Access Token not found in token response")
			w.WriteHeader(http.StatusInternalServerError)
			continue
		}
		accessToken = accessTokenData.(string)
		log.Printf("Access Token is '" + accessToken + "'")
		break
	}

	if accessToken == "" {
		log.Printf("Failed to get access token")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create certificate signing request
	csr, err := CreateCsr()
	if err != nil {
		log.Printf("Failed to create CSR: " + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get CSR endpoint
	csrEndpoint := os.Getenv("CSR_ENDPOINT")
	if csrEndpoint == "" {
		log.Printf("CSR_ENDPOINT not defined")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	httpClient := &http.Client{}
	// Send CSR to CSR Endpoint.
	csrRequest, err := http.NewRequest("POST", csrEndpoint, strings.NewReader(csr))
	if err != nil {
		log.Printf("Failed to send Certificate Signing Request: " + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Add request headers
	csrRequest.Header.Add("Authorization", "Bearer "+accessToken)
	csrRequest.Header.Add("Content-Type", "application/pkcs10")

	defer csrRequest.Body.Close()

	csrResponse, err := httpClient.Do(csrRequest)
	if err != nil {
		log.Printf("Failed to send CSR Request: " + err.Error())
		return
	}
	defer csrResponse.Body.Close()

	// Read CSR response body
	csrResponseBody, err := ioutil.ReadAll(csrResponse.Body)
	if err != nil {
		log.Printf("Failed to read CSR response: " + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Get filename of contract certificate file
	certificateFile := os.Getenv("OUTPUT_FILE")
	if certificateFile == "" {
		log.Printf("OUTPUT_FILE not defined")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write contract certificate to file
	err = WriteCertificate(csrResponseBody, certificateFile)
	if err != nil {
		log.Printf("Failed to write certificate")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Respond with success
	w.WriteHeader(http.StatusOK)
	log.Printf("Finished!")

	measureEnd := time.Now()
	measureDuration := time.Since(measureStart)
	if LogWriter != nil {
		_, err := LogWriter.WriteString("confirm_authorization," + fmt.Sprint(measureStart.UnixNano()) + "," + fmt.Sprint(measureEnd.UnixNano()) + "," + fmt.Sprint(measureDuration.Nanoseconds()) + "\r\n")
		if err != nil {
			log.Printf("Writing measurement failed: " + err.Error())
		}
	}
}

func CreateCsr() (string, error) {
	measureStart := time.Now()
	// Execute OpenSSL Command to generate CSR
	cmd := exec.Command("./scripts/csr.sh")
	if cmd == nil {
		return "", errors.New("failed to execute CSR")
	}

	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	log.Printf("CSR Output: ", string(out))

	// Read CSR file
	data, err := os.ReadFile("./output/request.csr")
	if err != nil {
		return "", err
	}

	measureEnd := time.Now()
	measureDuration := time.Since(measureStart)
	if LogWriter != nil {
		_, err := LogWriter.WriteString("create_csr," + fmt.Sprint(measureStart.UnixNano()) + "," + fmt.Sprint(measureEnd.UnixNano()) + "," + fmt.Sprint(measureDuration.Nanoseconds()) + "\r\n")
		if err != nil {
			log.Printf("Writing measurement failed: " + err.Error())
		}
	}

	// Return CSR file as string
	return string(data), nil
}

func WriteCertificate(csrResponse []byte, file string) error {
	measureStart := time.Now()

	err := os.WriteFile(file, csrResponse, 0400)

	measureEnd := time.Now()
	measureDuration := time.Since(measureStart)
	if LogWriter != nil {
		_, err := LogWriter.WriteString("write_cert," + fmt.Sprint(measureStart.UnixNano()) + "," + fmt.Sprint(measureEnd.UnixNano()) + "," + fmt.Sprint(measureDuration.Nanoseconds()) + "\r\n")
		if err != nil {
			log.Printf("Writing measurement failed: " + err.Error())
		}
	}

	return err
}
