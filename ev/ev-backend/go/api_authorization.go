/*
 * EV Backend
 *
 * API version: 0.0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package ev_backend

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"errors"
	"io"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"strings"
	"time"
)

type Session struct {
	PkceVerifier string
	EmspId       string
	RedirectUri  string
}

var sessions = make(map[string]Session)

var randomCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

var pkceChallengeCharSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"

var emspResources map[string]string

func GenerateRandomString(length int, charset string) string {
	random := rand.New(rand.NewSource(time.Now().UnixNano()))
	charsetLength := len(charset)
	result := make([]byte, length)
	for i := range result {
		result[i] = charset[random.Intn(charsetLength)]
	}
	return string(result)
}

func GetEmsp(id string) *Emsp {
	// Search in Emsps for eMSP with matching id.
	for _, emsp := range Emsps {
		if emsp.Id == id {
			return &emsp
		}
	}
	return nil
}

func GetDiscoveryDocument(baseUrl string) (map[string]interface{}, error) {
	// Build Discovery URL
	discoveryUrl := baseUrl + "/.well-known/openid-configuration"

	// Request discovery document
	resp, err := http.Get(discoveryUrl)
	if err != nil {
		return nil, err
	}

	// Read HTTP body
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse HTTP body
	var discoveryDocument map[string]interface{}
	err = json.Unmarshal(body, &discoveryDocument)
	if err != nil {
		return nil, err
	}

	return discoveryDocument, nil
}

func GetPkce() (string, string, error) {
	// Generate random PKCE Verifier
	pkceVerifier := GenerateRandomString(128, randomCharSet)

	// Encode Verifier to ASCII
	asciiEncodedVerifier := []byte(pkceVerifier)

	// Generate SHA-256 hash from ASCII-encoded verifier
	hash := sha256.New()
	_, err := hash.Write(asciiEncodedVerifier)
	if err != nil {
		return "", "", err
	}
	sha256Verifier := hash.Sum(nil)

	// Encode the SHA-256 hash to base64url
	pkceChallenge := base64.URLEncoding.EncodeToString(sha256Verifier)

	return pkceVerifier, pkceChallenge, nil
}

func RequestContractProvisioning(w http.ResponseWriter, r *http.Request) {
	// Parse Contract Provisioning Request body
	var cpr ContractProvisioningRequest
	err := json.NewDecoder(r.Body).Decode(&cpr)
	if err != nil {
		log.Printf("Failed to parse ContractProvisioningRequest")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Search for eMSP with requested ID
	emsp := GetEmsp(cpr.EmspId)
	if emsp == nil {
		log.Printf("Unknown eMSP with ID \"" + cpr.EmspId + "\"")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	emspCreds := GetEmspCredential(emsp.Id)
	if emspCreds == nil {
		log.Printf("Unknown eMSP Credentials with ID \"" + emsp.Id + "\"")
		w.WriteHeader(http.StatusNotFound)
		return
	}

	// Get discovery document
	discoveryDocument, err := GetDiscoveryDocument(emsp.BaseUrl)
	if err != nil {
		log.Printf("Failed to load discovery document for eMSP with Base URL \"" + emsp.BaseUrl + "\"")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Get PAR endpoint from discovery document
	parEndpoint, found := discoveryDocument["pushed_authorization_request_endpoint"].(string)
	if !found {
		log.Printf("eMSP \"" + emsp.BaseUrl + "\" does not support Pushed Authorization Requests")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Prepare PKCE
	pkceVerifier, pkceChallenge, err := GetPkce()
	if err != nil {
		log.Printf("Failed to generate PKCE challenge")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create new session
	sessionId := GenerateRandomString(20, randomCharSet)
	sessions[sessionId] = Session{
		PkceVerifier: pkceVerifier,
		EmspId:       emsp.Id,
		RedirectUri:  cpr.RedirectUri,
	}

	// Get resource server endpoint URL
	resourceEp, found := emspResources[emspCreds.ClientId]
	if !found {
		log.Printf("Resource Endpoint not found for client with ID \"" + emspCreds.ClientId + "\"")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Encode authorization details:
	var authorizationDetailJson map[string]interface{}
	authorizationDetailJson["type"] = "pnc_contract_request"
	authorizationDetailJson["actions"] = [1]string{
		"contract_provisioning",
	}
	authorizationDetailJson["locations"] = [1]string{resourceEp}
	authorizationDetailJson["charging_period"] = *cpr.AuthorizationDetail.ChargingPeriod
	authorizationDetailJson["maximum_amount"] = *cpr.AuthorizationDetail.MaximumAmount
	authorizationDetailJson["maximum_transaction_amount"] = *cpr.AuthorizationDetail.MaximumTransactionAmount
	var authorizationDetailsJson [1]map[string]interface{}
	authorizationDetailsJson[0] = authorizationDetailJson
	authorizationDetails, err := json.Marshal(authorizationDetailsJson)
	if err != nil {
		log.Printf("Failed to serialize authorization details")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Prepare body parameters for PAR
	bodyParameters := url.Values{}
	// OAuth Authorization parameters according to RFC 6749:
	bodyParameters.Set("response_type", "code")
	bodyParameters.Set("redirect_uri", cpr.RedirectUri)
	bodyParameters.Set("scope", "ccsr")
	bodyParameters.Set("client_id", emspCreds.ClientId)
	bodyParameters.Set("state", sessionId)
	// PKCE parameters according to RFC 7636:
	bodyParameters.Set("code_challenge", pkceChallenge)
	bodyParameters.Set("code_challenge_method", "S256")
	// RAR parameters according to RFC 9396:
	bodyParameters.Set("authorization_details", url.QueryEscape(string(authorizationDetails)))

	// Encode body parameters to string
	bodyString := bodyParameters.Encode()

	log.Printf("Sending pushed authorization request with body \"%q\"", bodyString)

	// Send PAR
	parResponse, err := http.Post(parEndpoint, "application/x-www-form-urlencoded", strings.NewReader(bodyString))
	if err != nil {
		log.Printf("Failed to send Pushed Authorization Request: " + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Read PAR response body
	defer parResponse.Body.Close()
	body, err := io.ReadAll(parResponse.Body)
	if err != nil {
		log.Printf("Failed to read PAR response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Parse PAR response body
	var responseBody ParResponseBody
	err = json.Unmarshal(body, &responseBody)
	if err != nil {
		log.Printf("Failed to parse PAR response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create and serialize response
	result := ContractProvisioningResponse{
		RequestUri: responseBody.RequestUri,
		ClientId:   emspCreds.ClientId,
		State:      sessionId,
	}
	resultData, err := json.Marshal(result)
	if err != nil {
		log.Printf("Failed to serialize response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write serialized result
	_, err = w.Write(resultData)
	if err != nil {
		log.Printf("Failed to write response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write header and status code
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
}

func LoadEmspResourceEps(file string) error {
	// Read emsp resource endpoint file
	data, err := os.ReadFile(file)
	if err != nil {
		return err
	}

	// JSON serialize values
	err = json.Unmarshal(data, &emspResources)
	if err != nil {
		return err
	}

	return nil
}

func ConfirmAuthorization(w http.ResponseWriter, r *http.Request) {
	// Parse Confirmation Request body
	var confirmationRequest ConfirmationRequest
	err := json.NewDecoder(r.Body).Decode(&confirmationRequest)
	if err != nil {
		log.Printf("Failed to parse ConfirmationRequest")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Get session, eMSP, and eMSP credentials
	session, found := sessions[confirmationRequest.State]
	if !found {
		log.Printf("Session \"" + confirmationRequest.State + "\" not found")
		w.WriteHeader(http.StatusNotFound)
		return
	}
	emsp := GetEmsp(session.EmspId)
	if emsp == nil {
		log.Printf("eMSP with ID \"" + session.EmspId + "\" not found")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	emspCreds := GetEmspCredential(emsp.Id)
	if emspCreds == nil {
		log.Printf("Unknown eMSP Credentials with ID \"" + emsp.Id + "\"")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Discover Authorization Server
	discoveryDocument, err := GetDiscoveryDocument(emsp.BaseUrl)
	if err != nil {
		log.Printf("Failed to get discovery document from Authorization Server")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Get Token Endpoint from discovery document
	tokenEndpoint, found := discoveryDocument["token_endpoint"].(string)
	if !found {
		log.Printf("eMSP \"" + emsp.BaseUrl + "\" does not support Token Endpoint")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Prepare body parameters
	tokenRequestBodyParameters := url.Values{}
	// OAuth Authorization parameters according to RFC 6749:
	tokenRequestBodyParameters.Set("grant_type", "authorization_code")
	tokenRequestBodyParameters.Set("code", confirmationRequest.AuthCode)
	tokenRequestBodyParameters.Set("redirect_uri", session.RedirectUri)
	tokenRequestBodyParameters.Set("client_id", emspCreds.ClientId)
	tokenRequestBodyParameters.Set("client_secret", emspCreds.ClientSecret)
	// PKCE parameters according to RFC 7636:
	tokenRequestBodyParameters.Set("code_verifier", session.PkceVerifier)
	// Encode body parameters to string
	tokenRequestBodyString := tokenRequestBodyParameters.Encode()

	// Send Token Request to Token Endpoint.
	tokenRequest, err := http.NewRequest("POST", tokenEndpoint, strings.NewReader(tokenRequestBodyString))
	if err != nil {
		log.Printf("Failed to send Token Request")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer tokenRequest.Body.Close()

	// Read Token response body
	defer tokenRequest.Response.Body.Close()
	tokenResponseBodyString, err := io.ReadAll(tokenRequest.Response.Body)
	if err != nil {
		log.Printf("Failed to read Token response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Parse Token response body
	var tokenResponseBody map[string]interface{}
	err = json.Unmarshal(tokenResponseBodyString, &tokenResponseBody)
	if err != nil {
		log.Printf("Failed to parse Token response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get access token from token response body
	accessToken, found := tokenResponseBody["access_token"].(string)
	if !found {
		log.Printf("Access Token not found in token response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create certificate signing request
	csr, err := CreateCsr()
	if err != nil {
		log.Printf("Failed to create CSR")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Get CSR endpoint
	csrEndpoint := os.Getenv("CSR_ENDPOINT")
	if csrEndpoint != "" {
		log.Printf("CSR_ENDPOINT not defined")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Send CSR to CSR Endpoint.
	csrRequest, err := http.NewRequest("POST", csrEndpoint, strings.NewReader(csr))
	if err != nil {
		log.Printf("Failed to send Certificate Signing Request")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer csrRequest.Body.Close()
	// Add request headers
	csrRequest.Header.Add("content-type", "application/pkcs10")
	csrRequest.Header.Add("authorization", "bearer "+accessToken)

	// Read CSR response body
	defer csrRequest.Response.Body.Close()
	csrResponseBodyString, err := io.ReadAll(csrRequest.Response.Body)
	if err != nil {
		log.Printf("Failed to read CSR response")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Get filename of contract certificate file
	certificateFile := os.Getenv("OUTPUT_FILE")
	if certificateFile == "" {
		log.Printf("OUTPUT_FILE not defined")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// Write contract certificate to file
	err = WriteCertificate(csrResponseBodyString, certificateFile)
	if err != nil {
		log.Printf("Failed to write certificate")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Respond with success
	w.WriteHeader(http.StatusOK)
}

func CreateCsr() (string, error) {
	// Execute OpenSSL Command to generate CSR
	cmd := exec.Command("./scripts/csr.sh")
	if cmd == nil {
		return "", errors.New("Failed to execute CSR")
	}

	// Read CSR file
	data, err := os.ReadFile("./request.csr")
	if err != nil {
		return "", err
	}

	// Return CSR file as string
	return string(data), nil
}

func WriteCertificate(csrResponse []byte, file string) error {
	err := os.WriteFile(file, csrResponse, 0400)
	return err
}
